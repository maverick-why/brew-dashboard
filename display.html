// /api/public.js
const Redis = require("ioredis");
const { sanitizeState, safeStr } = require("./_schema");

const KEY = "brew_dash_records_v1";

// ====== 温控故事规则
const COOL_DAYS = 10; // 倒数10天开始降温
const COOL_WINDOW_MS = COOL_DAYS * 86400000;

const SETPOINT_MIN = 18.2;
const SETPOINT_MAX = 19.9;

const FINAL_MIN = 4.0;
const FINAL_MAX = 5.0;

// 温度状态单独存（避免写回主数据）
const TEMP_STATE_KEY = "brew_dash_temp_state_v1";

// 每 60 秒一个桶更新温度（你要求：刷新差 <= 0.3，不用每秒抖）
const TEMP_BUCKET_MS = 60 * 1000;

let redis;
function getRedis() {
  if (!redis) {
    if (!process.env.REDIS_URL) throw new Error("REDIS_URL is missing");
    redis = new Redis(process.env.REDIS_URL, {
      maxRetriesPerRequest: 1,
      enableReadyCheck: false,
      lazyConnect: true,
    });
  }
  return redis;
}

// ====== utils
function clamp(x, a, b) {
  return Math.max(a, Math.min(b, x));
}

function round1(x) {
  return Math.round(Number(x) * 10) / 10;
}

function fmtTemp(x) {
  return `${round1(x).toFixed(1)}℃`;
}

function pad2(n) {
  return String(n).padStart(2, "0");
}

function formatMDshort(dateStr) {
  if (!dateStr) return "--/--";
  const d = new Date(dateStr);
  if (isNaN(d)) return "--/--";
  return `${pad2(d.getMonth() + 1)}/${pad2(d.getDate())}`;
}

function tankNoFromId(id) {
  const m = /^F(\d+)$/i.exec(id || "");
  if (m) return Number(m[1]);
  const n = String(id || "").match(/\d+/);
  return n ? Number(n[0]) : 0;
}

function parseTempNumber(v) {
  if (v === undefined || v === null || v === "") return null;
  const t = String(v).trim().replace("℃", "").replace("°C", "").replace("°", "").trim();
  const n = Number(t);
  if (Number.isNaN(n)) return null;
  return n;
}

// 简单稳定 hash
function hash32(str) {
  let h = 2166136261;
  for (let i = 0; i < str.length; i++) {
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return h >>> 0;
}

// xorshift32 PRNG（稳定可复现；加 salt 增加不可猜性）
function rngFromSeed(seedU32) {
  let x = seedU32 >>> 0;
  return () => {
    x ^= x << 13;
    x ^= x >>> 17;
    x ^= x << 5;
    return (x >>> 0) / 4294967296;
  };
}

function toABV(v) {
  const s = safeStr(v, "");
  if (!s) return "--";
  if (s.includes("%")) return s;
  const n = Number(String(s).trim());
  if (!Number.isNaN(n)) return `${n}%`;
  return s;
}

function calcProgress(startStr, endStr, nowMs) {
  const s = new Date(startStr).getTime();
  const e = new Date(endStr).getTime();
  if (!Number.isFinite(s) || !Number.isFinite(e) || e <= s) return 0;
  let p = ((nowMs - s) / (e - s)) * 100;
  p = clamp(p, 0, 100);
  return Math.round(p);
}

function daysSince(startStr, nowMs) {
  if (!startStr) return null;
  const s = new Date(startStr).getTime();
  if (!Number.isFinite(s)) return null;
  const ms = nowMs - s;
  if (ms < 0) return 0;
  return Math.floor(ms / 86400000) + 1;
}

// 平滑目标曲线：cosine easing
function cosineEase01(t01) {
  const t = clamp(t01, 0, 1);
  return (1 - Math.cos(Math.PI * t)) / 2;
}

// 每个罐一个稳定 setpoint：18.2~19.9（步进0.1）
function makeStableSetpoint(id, startStr) {
  const salt = process.env.DISPLAY_SALT || "brew";
  const seed = hash32(`${salt}|sp|${id}|${startStr || ""}`);
  const rand = rngFromSeed(seed);
  const steps = Math.round((SETPOINT_MAX - SETPOINT_MIN) / 0.1); // 17
  const idx = Math.floor(rand() * (steps + 1));
  const t = SETPOINT_MIN + idx * 0.1;
  return clamp(Math.round(t * 10) / 10, SETPOINT_MIN, SETPOINT_MAX);
}

// 每个罐一个稳定 final：4.0~5.0（步进0.1）
function makeStableFinal(id, endStr) {
  const salt = process.env.DISPLAY_SALT || "brew";
  const seed = hash32(`${salt}|final|${id}|${endStr || ""}`);
  const rand = rngFromSeed(seed);
  const steps = Math.round((FINAL_MAX - FINAL_MIN) / 0.1); // 10
  const idx = Math.floor(rand() * (steps + 1));
  const t = FINAL_MIN + idx * 0.1;
  return clamp(Math.round(t * 10) / 10, FINAL_MIN, FINAL_MAX);
}

async function getTempState(r, id) {
  const raw = await r.hget(TEMP_STATE_KEY, id);
  if (!raw) return null;
  try {
    return JSON.parse(raw);
  } catch {
    return null;
  }
}

async function setTempState(r, id, st) {
  await r.hset(TEMP_STATE_KEY, id, JSON.stringify(st));
}

/**
 * 计算单个罐的温度 + 状态：
 * - fermenting：恒温 setpoint
 * - cooling：倒数10天平滑降温到 4~5
 * - ready：到/过期：即将开罐（保持 4~5）
 *
 * 温度变化每桶（60s） <= 0.3℃
 * 允许轻微回弹 +0.1（更真实）
 * 后台改 start/end 会自动重置/贴近新曲线（修复你遇到的不变 bug）
 */
async function computeTempForTank(r, id, row, nowMs) {
  const startStr = safeStr(row.start, "");
  const endStr = safeStr(row.end, "");

  const startMs = new Date(startStr).getTime();
  const endMs = new Date(endStr).getTime();

  const endOk = Number.isFinite(endMs);
  const startOk = Number.isFinite(startMs);

  // setpoint：如果后台填了 temp，就当作设定温度；否则生成稳定 setpoint
  const backendTemp = parseTempNumber(row.temp);
  const setpoint =
    backendTemp !== null
      ? clamp(backendTemp, SETPOINT_MIN, SETPOINT_MAX)
      : makeStableSetpoint(id, startStr);

  const finalT = makeStableFinal(id, endStr);

  // 没有合法 end：就一直发酵中（恒温）
  if (!endOk) {
    return { tempText: fmtTemp(setpoint), statusOut: "fermenting", badgeCN: "发酵中" };
  }

  // 冷却开始：end-10天，但不能早于 start
  const coolStartMs = Math.max(
    endMs - COOL_WINDOW_MS,
    startOk ? startMs : endMs - COOL_WINDOW_MS
  );

  // 状态判定
  const isCooling = nowMs >= coolStartMs && nowMs < endMs;
  const isReady = nowMs >= endMs;

  const statusOut = isReady ? "ready" : isCooling ? "cooling" : "fermenting";
  const badgeCN = isReady ? "即将开罐" : isCooling ? "降温冷沉" : "发酵中";

  // 目标温度 target
  let target = setpoint;

  if (isCooling) {
    const denom = Math.max(1, endMs - coolStartMs);
    const t01 = (nowMs - coolStartMs) / denom;
    const k = cosineEase01(t01);
    target = setpoint + (finalT - setpoint) * k;
  } else if (isReady) {
    target = finalT;
  } else {
    target = setpoint;
  }

  // 当前桶
  const bucket = Math.floor(nowMs / TEMP_BUCKET_MS);

  // 读状态
  let st = await getTempState(r, id);

  // 判断“关键参数是否变化”（后台改日期要立刻生效）
  const sig = `${startStr}|${endStr}|${round1(setpoint)}|${round1(finalT)}|${coolStartMs}`;

  const needInit =
    !st ||
    typeof st.cur !== "number" ||
    st.sig !== sig;

  // 初始化/重置：发酵中直接给 setpoint；降温中贴近 target；即将开罐贴近 final
  if (needInit) {
    let initCur = setpoint;

    if (isCooling) {
      // 贴近新目标（避免你改 end 后温度卡住）
      initCur = Math.min(setpoint, target + 0.3);
    } else if (isReady) {
      initCur = finalT;
    } else {
      initCur = setpoint;
    }

    st = {
      sig,
      cur: initCur,
      lastBucket: bucket,
    };
    await setTempState(r, id, st);
    return { tempText: fmtTemp(st.cur), statusOut, badgeCN };
  }

  // 同桶不更新（减少抖动）
  if (st.lastBucket === bucket) {
    // 到期后确保不高于 final
    if (isReady) {
      st.cur = Math.min(st.cur, finalT);
      await setTempState(r, id, st);
    }
    return { tempText: fmtTemp(st.cur), statusOut, badgeCN };
  }

  // 进入新桶：更新温度
  st.lastBucket = bucket;

  const prev = st.cur;

  // 发酵中：恒温
  if (statusOut === "fermenting") {
    st.cur = setpoint;
    await setTempState(r, id, st);
    return { tempText: fmtTemp(st.cur), statusOut, badgeCN };
  }

  // 即将开罐：锁定 4~5
  if (statusOut === "ready") {
    st.cur = Math.min(prev, finalT);
    st.cur = clamp(st.cur, FINAL_MIN, FINAL_MAX);
    await setTempState(r, id, st);
    return { tempText: fmtTemp(st.cur), statusOut, badgeCN };
  }

  // 降温冷沉：每次变化 <=0.3，允许 +0.1 回弹，但整体围绕 target 下降
  // 允许窗口：
  // - 相对上次：[-0.3, +0.1]
  // - 相对 target：[-0.3, +0.1]
  const upper = Math.min(prev + 0.1, target + 0.1);
  const lower = Math.max(prev - 0.3, target - 0.3);

  // 伪随机（稳定不可猜）：盐 + id + bucket + prev/target
  const salt = process.env.DISPLAY_SALT || "brew";
  const seed = hash32(`${salt}|cool|${id}|${bucket}|${round1(prev)}|${round1(target)}`);
  const rand = rngFromSeed(seed);

  const gap = prev - target; // >0：当前比目标高（需要降）

  let pool;
  if (gap > 1.2) pool = [-0.3, -0.3, -0.2, -0.2, -0.1];    // 追赶下降
  else if (gap > 0.6) pool = [-0.3, -0.2, -0.2, -0.1, 0];
  else if (gap > 0.2) pool = [-0.2, -0.1, -0.1, 0, +0.1];
  else pool = [-0.1, 0, 0, +0.1, -0.1];

  const step = pool[Math.floor(rand() * pool.length)];
  let next = prev + step;

  // 硬约束：不超过允许窗口
  next = clamp(next, lower, upper);

  // 全局合理范围：不会高过设定温度，也不会低过 final（太低不真实）
  next = clamp(next, FINAL_MIN, SETPOINT_MAX);

  // 临近/到期：确保最终能收敛到 final（不会上跳）
  if (nowMs >= endMs) next = Math.min(next, finalT);

  st.cur = next;
  await setTempState(r, id, st);

  return { tempText: fmtTemp(next), statusOut, badgeCN };
}

module.exports = async (req, res) => {
  try {
    res.setHeader("Content-Type", "application/json; charset=utf-8");
    res.setHeader("Cache-Control", "no-store");

    const r = getRedis();
    const val = await r.get(KEY);
    const nowMs = Date.now();

    if (!val) {
      return res.status(200).end(JSON.stringify({ ok: true, items: [], server_time: nowMs }));
    }

    let obj = {};
    try {
      obj = JSON.parse(val);
    } catch {
      obj = {};
    }

    const cleaned = sanitizeState(obj);

    const entries = Object.entries(cleaned)
      .map(([id, row]) => ({ id, ...row }))
      .filter((x) => x.show === true)
      .sort((a, b) => tankNoFromId(a.id) - tankNoFromId(b.id));

    const items = [];
    for (const item of entries) {
      const progress = calcProgress(item.start, item.end, nowMs);
      const day = daysSince(item.start, nowMs);

      const tempRes = await computeTempForTank(r, item.id, item, nowMs);

      items.push({
        id: item.id,
        no: tankNoFromId(item.id),
        limited: item.limited === true,

        beer: safeStr(item.beer, "（未命名）"),
        style: safeStr(item.style, "--"),

        abv: toABV(item.abv),
        ibu: safeStr(item.ibu, "--"),
        capacity: safeStr(item.capacity, "--"),

        temp: tempRes.tempText,

        start_md: formatMDshort(item.start),
        end_md: formatMDshort(item.end),

        progress,

        // ✅ 三态：fermenting / cooling / ready
        status: tempRes.statusOut,
        badgeCN: tempRes.badgeCN,

        dayText: day === null ? "DAY --" : `DAY ${day}`,
      });
    }

    return res.status(200).end(JSON.stringify({ ok: true, items, server_time: nowMs }));
  } catch (e) {
    return res.status(500).end(JSON.stringify({ ok: false, error: String(e.message || e) }));
  }
};
